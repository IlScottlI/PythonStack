# Intro to OOP

## Objectives:

-   Introduction to object oriented programming and its benefits

----------

**OOP (Object Oriented Programming)** is something that has revolutionized the way programming is done today. If used correctly, it can save you loads of time. It will also help you to avoid repeating code that solves the same simple problem, making code maintenance easy. In this chapter, you'll learn how to use and implement OOP.

Understanding object-oriented programming principles is the key to making your code more organized and modular. This chapter will teach you object-oriented programming principles to help you better understand how to organize your code in the future.

The goal of this chapter is to help us understand:

-   what  **objects and classes**  are and why they are useful,
-   how to create classes and objects in Python,
-   the basic building blocks of objects (**attributes**  and  **methods**),
-   more advanced OOP concepts (inheritance, super, etc.),
-   how data structures utilize OOP concepts, and
-   the difference between procedural and OOP code.

Would it surprise you to know that you have been taking advantage of OOP already? For example, you know that you can call the  `append`  method if you're working with a list, but not with a dictionary or a number. You know that you can get the length of a list or dictionary, but not of a boolean. That is because each type of thing, or  _object_, has specific properties and functionality associated with it.

This grouping, or  _encapsulating_, of properties and functionalities by object is a fundamental principle of OOP and is implemented with  **classes**.

To better understand these concepts, we'll start by creating some of our own classes by representing real-world things, and then go a little more abstract as we peek inside of a few data structures.

Video Overview

<iframe width="560" height="315" src="https://www.youtube.com/embed/nDyPazWPVA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

##

# Classes

## Objectives:

-   Understand what a class is
-   Learn the syntax for defining and instantiating a class

----------

Whenever we declare a variable, we are creating an  _instance_  of a class. For example, by declaring  `x = [1,2,3]`, x is an  _instance_  of a list. An instance is simply an object that follows the pattern defined by its class.

So far we have been using data types that come with the Python language. With OOP, we are able to create our own custom data types! This is done by writing a class. A class is like a blueprint that ensures the consistent creation of instances.

Let's consider an example of a custom class we'll need in the context of web development. As almost all applications revolve around users, almost all applications define a User class. Say we have been contracted to build a banking application. The information we need about a user for a banking application would be different than what we would need if we were building a social media application. If we allowed each user to decide what information they wanted to provide to us, you can imagine how difficult it would be to sift through and utilize that information. Instead, we design a class on the backend that will dictate what information the user is required to provide. This ensures consistent creation of User instances.

Here's the syntax for creating a class that we want to call User:

class User:
    pass    # we'll fill this in shortly

And here's how we create a new instance of our class:

michael = User()
anna = User()

Over the next few tabs, we'll start flushing out our User class with:

-   **Attributes:**  Characteristics shared by all instances of the class type.
-   **Methods:**  Actions that an object can perform. A user, for example, should be able to make a deposit or a withdrawal, or maybe send money to another user.

Let's dive in!

# Attributes

## Objectives:

-   Learn how to set the attributes of a class
-   Get familiar with the __init__() method

----------

Let's start building our User class by adding attributes. Again,  **attributes**  are characteristics of an object. For example, in our banking application, we may be interested in their name, email, and account balance. Attributes are defined in a "magic method" called  `__init__`, which method is called when a new object is instantiated.
```py
class User:		# declare a class and give it name User
    def __init__(self):
        self.name = "Michael"
        self.email = "michael@codingdojo.com"
        self.account_balance = 0
```
**The first parameter of every method within a class will be  `self`**, and the  **class's attribute names are also indicated by  `self.`**. We'll talk more about  `self`  later, but for now just follow this pattern:  `self.<<attribute_name_of_your_choosing>>`.

Then to instantiate a couple of new users:
```py
guido = User()
monty = User()
```
If we want to access our instance's attributes, we can refer to them from our instances by name:
```py
print(guido.name)	# output: Michael
print(monty.name)	# output: Michael
```
We can also set the values for our instance's attributes:
```py
guido.name = "Guido"
monty.name = "Monty"
```
While we definitely want every user to have a name, email, and account balance, we don't want all of our users to have the same name and email address upon creation. How will we know what the name should be?

**With the  `__init__`  method's  _parameters_, we indicate what needs to be provided (i.e.  _arguments_) when the class is instantiated.**  (`self`  is always passed in implicitly.)

In our example, even though we have 3 attributes, we only require input for 2 of them. When the User instance is created, we should expect to receive specific values for the name and email address. We'll assume, however, that everyone starts with $0 in their account. Let's adjust our code to allow  _arguments_  to be passed in upon instantiation:
```py
class User:
    def __init__(self, name, email_address):# now our method has 2 parameters!
        self.name = name			# and we use the values passed in to set the name attribute
        self.email = email_address		# and the email attribute
        self.account_balance = 0		# the account balance is set to $0, so no need for a third parameter
```
Now when we want to create users, we must send in the 2 required arguments:
```py
guido = User("Guido van Rossum", "guido@python.com")
monty = User("Monty Python", "monty@python.com")
print(guido.name)	# output: Guido van Rossum
print(monty.name)	# output: Monty Python
```
Much better!

# Methods

## Objectives

-   Learn how to add methods to a class
-   Understand the purpose and meaning of  `self`

----------

Now it's time to add some functionality to our class.  **Methods**  are just functions that belong to a class. This means that we can't call them independently as we have called functions previously; rather, methods must be called from an instance of a class. For example, if a user wanted to make a deposit, we'd want to be able to call the method  _from the user instance_; because a specific user is making a deposit, it should only affect that user's balance. Making such a call would look something like this:
```py
guido.make_deposit(100)
```
To be able to call on this method, it needs to exist. Let's make it!
```py
class User:		# here's what we have so far
    def __init__(self, name, email):
        self.name = name
        self.email = email
        self.account_balance = 0
    # adding the deposit method
    def make_deposit(self, amount):	# takes an argument that is the amount of the deposit
    	self.account_balance += amount	# the specific user's account increases by the amount of the value received
```
Don't forget that  **the first parameter of every method within a class should be  `self`**. Notice that, in addition to whatever arguments are passed in as a traditional function,  _methods also have access to the class's attributes_.

Now that our method is written, we can call it:
```py
guido.make_deposit(100)
guido.make_deposit(200)
monty.make_deposit(50)
print(guido.account_balance)	# output: 300
print(monty.account_balance)	# output: 50
```
### Self

It's probably time to talk about  **self**. The  **self**  parameter includes all the information about the individual object that has called the method. But how does it get passed in? Based on the signature for the deposit method or the __init__ method, they require 2 and 3 arguments, respectively. However, when we call on them, we pass in only 1 and 2. What's happening here? Because we are calling on the method  _from the instance_, this is known as  **implicit passage of self**. When we call on a method from an instance, that instance, along with all of its information (name, email, balance), is passed in as  _self_.

# Quiz

  
1. If we wanted to define a new class we would start with which line

- [ ]  def ClassName(object):
- [ ]  def ClassName(self):
- [ ]  class ClassName():
- [x]  class ClassName:
- [ ]  None of the above

2. The __init__() function gets called when the object is constructed

- [x]  True
- [ ]  False

3. You cannot define an __init__() function that has parameters

- [ ]  True
- [x]  False

4. How do you pass arguments to the __init__() function?

- [ ]  Creating an object instance, then call the __init__() function on the object by passing in the specified parameters
- [ ]  You cannot pass arguments into a __init__() function
- [x]  When creating an object instance you pass the arguments to the specified class you are creating an instance of
- [ ]  Creating an object within the class and calling the __init__() function passing the specified parameters

5. What is the purpose of an __init__() function?

- [ ]  To prevent you from rewriting the same code each time you create a new object
- [ ]  To set properties required to execute certain instance methods as soon as the object is instantiated
- [ ]  To execute whatever logic we want to for each object that is created
- [x]  All of the above

6. A constructor function cannot call any other methods inside the class.

- [ ]  True
- [x]  False

# Assignment: User

## Objectives:

-   Practice creating a class and making instances from it
-   Practice accessing the methods and attributes of different instances

----------

If you've been following along, you're going to utilize the  **User**  class we've been discussing for this assignment.

For this assignment, we'll add some functionality to the User class:

-   **make_withdrawal(self, amount)**  - have this method decrease the user's balance by the amount specified
-   **display_user_balance(self)**  - have this method print the user's name and account balance to the terminal

-   eg. "User: Guido van Rossum, Balance: $150

-   **BONUS: transfer_money(self, other_user, amount)**  - have this method decrease the user's balance by the amount and add that amount to other other_user's balance

- [ ]  Create a file with the User class, including the __init__ and make_deposit methods
    
- [ ]  Add a make_withdrawal method to the User class
    
- [ ]  Add a display_user_balance method to the User class
    
- [ ]  Create 3 instances of the User class
    
- [ ]  Have the first user make 3 deposits and 1 withdrawal and then display their balance
    
- [ ]  Have the second user make 2 deposits and 2 withdrawals and then display their balance
    
- [ ]  Have the third user make 1 deposits and 3 withdrawals and then display their balance
    
- [ ]  BONUS: Add a transfer_money method; have the first user transfer money to the third user and then print both users' balances

# Chaining Methods

## Objectives:

-   Understand how to chain methods

----------

In the last assignment, your code might have looked something like this:
```py
guido.make_deposit(100)
guido.make_deposit(200)
guido.make_deposit(300)
guido.make_withdrawal(50)
guido.display_user_balance()
```
This takes up a lot of space and we're repeating our call to  _guido_  many times. There is a way to call on  _guido_  just once and keep attaching new method calls to the end of the previous one, like so:
```py
guido.make_deposit(100).make_deposit(200).make_deposit(300).make_withdrawal(50).display_user_balance()
```
This is called  **chaining**. In order for this to work, each method must return  _self_. By returning self, if we recall how functions work, each method call will now be equal to the instance that called it.

For example if  `guido.make_deposit(100)`  returns its own instance (_guido_), then we can call one of that instance's methods after that call, like  `guido.make_deposit(100).make_withdrawal(50)`.
```py
class User:
    def make_deposit(self, amount):
        # your code goes here...
        return self
```
The practice of having OOP return its own instance is pretty common and is done in other programming languages, though the variable name in some languages is not  `self`, but instead `this`.

- [ ]  Update your previous assignment so that each instance's methods are chained

# Assignment: BankAccount

## Objectives

-   Practice writing classes

----------

As we continue thinking about our banking application, we realize that it would be more accurate to assign a balance not to the user directly, but that in the real world, users have  _accounts_, and  _accounts_  have balances. This gives us the idea that maybe an account  _is its own class_! But as we stated, it is not completely independent of a class; accounts only exist because users open them.

_For this assignment, don't worry about putting any user information in the BankAccount class. We'll take care of that in the next lesson!_

Let's first just get some more practice writing classes by writing a new  _BankAccount_  class.

The BankAccount class should have a balance. When a new BankAccount instance is created, if an amount is given, the balance of the account should initially be set to that amount; otherwise, the balance should start at $0. The account should also have an interest rate, saved as a decimal (i.e. 1% would be saved as 0.01), which should be provided upon instantiation. (Hint: when using default values in parameters, the order of parameters matters!)

The class should also have the following methods:

-   **deposit(self, amount)**  - increases the account balance by the given amount
-   **withdraw(self, amount)**  - decreases the account balance by the given amount if there are sufficient funds; if there is not enough money, print a message "Insufficient funds: Charging a $5 fee" and deduct $5
-   **display_account_info(self)**  - print to the console: eg. "Balance: $100"
-   **yield_interest(self)**  - increases the account balance by the current balance * the interest rate (as long as the balance is positive)

This means we need a class that looks something like this:
```py
class BankAccount:
	def __init__(self, int_rate, balance): # don't forget to add some default values for these parameters!
		# your code here! (remember, this is where we specify the attributes for our class)
                # don't worry about user info here; we'll involve the User class soon
	def deposit(self, amount):
		# your code here
	def withdraw(self, amount):
		# your code here
	def display_account_info(self):
		# your code here
	def yield_interest(self):
		# your code here
```
- [ ]  Create a BankAccount class with the attributes interest rate and balance
    
- [ ]  Add a deposit method to the BankAccount class
    
- [ ]  Add a withdraw method to the BankAccount class
    
- [ ]  Add a display_account_info method to the BankAccount class
    
- [ ] Add a yield_interest method to the BankAccount class
    
- [ ] Create 2 accounts
    
- [ ]  To the first account, make 3 deposits and 1 withdrawal, then yield interest and display the account's info all in one line of code (i.e. chaining)
    
- [ ]  To the second account, make 2 deposits and 4 withdrawals, then yield interest and display the account's info all in one line of code (i.e. chaining)

#

# Association Between Classes

## Objectives:

-   Understand how different classes might relate to one another
-   Practice writing classes with attributes of a custom type

----------

Now that we have a User class and a BankAccount class, let's think about the relationship between them: a user  _has a_  bank account, or, in OOP terms, there is an  _association_  between these two classes. What this means is that, instead of keeping track of a balance directly in the User class, we'll  _encapsulate_  all the bank account information and associate a user with a specific instance of a Bank Account.

To keep things simple, let's start by assuming that each user has just one account that starts with a $0 balance and an interest rate of 2%. This means that the User class, instead of directly having a balance attribute, will now have an attribute of type BankAccount. To establish this relationship, we can update our User's __init__ method to something like this, removing the  `account_balance`  attribute and adding an  `account`  attribute:
```python
class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email
        self.account = BankAccount(int_rate=0.02, balance=0)	# added this line
```
Note: The BankAccount class should be in the same file as the User class, so the reference to it is recognized. Take a look into  _modularization_  if you feel the need to have the 2 classes in separate files.

We interact with this new attribute just as we do with previous attributes--the only difference is that we have personally defined the functionality of this class! We know the attributes and methods available to the  `account`  attribute by looking at our BankAccount class.
```python
class User:
    def example_method(self):
        self.account.deposit(100)		# we can call the BankAccount instance's methods
    	print(self.account.balance)		# or access its attributes
```

# Assignment: Users with Bank Accounts

## Objectives:

-   Practice writing classes with associations

----------

Update your existing User class to have an association with the BankAccount class. You should not have to change anything in the BankAccount class. The method signatures of the User class (the first line of the method with the  `def`  keyword) should also remain the same.

For example, our User class currently has a method like this:
```python
class User:
    # other methods
    def make_deposit(self, amount):
    	self.account_balance += amount	# hmmm...the User class doesn't have an account_balance attribute anymore
```
But our User class no longer has a  `self.account_balance`  attribute. Instead, we have replaced this with an  _instance_  of a BankAccount by the name of  `self.account`. That means our make_deposit (and other methods referencing self.account_balance) need to be updated! That's the goal of this assignment.

Remember in our User methods, we can now access the BankAccount class through our  `self.account`  attribute, like so:
```python
class User:
    def example_method(self):
        self.account.deposit(100)		# we can call the BankAccount instance's methods
    	print(self.account.balance)		# or access its attributes
```
- [ ]  Update the User class __init__ method
    
- [ ]  Update the User class make_deposit method
    
- [ ]  Update the User class make_withdrawal method
    
- [ ]  Update the User class display_user_balance method
    
- [ ] SENSEI BONUS: Allow a user to have multiple accounts; update methods so the user has to specify which account they are withdrawing or depositing to

#

# Modules & Packages

## Objectives:

-   Learn what a Python module is
-   Learn how to make and use modules in our code
-   Learn what a Python package is

----------

## Modules

Modules are simply Python files with the  `.py`  extension which implement a set of functions. Modules are imported using the  `import`  command.

The first time a module is loaded into a running Python script, it is initialized by executing the code in the module once. If another module in your code imports the same module again, it will not be loaded twice but once only - so local variables inside the module act as a "singleton" - they are initialized only once.

Now if we want to import the  _urllib.request_  module, which enables us to request data from URLs, we can simply import the module:
```python
# import the library
import urllib.request
response = urllib.request.urlopen("http://www.codingdojo.com")
html = response.read()
print(html)
```
Notice how we used  `urllib.request`  as a variable to refer to our module and then we called the methods using dot notation.

### Creating Your Own Modules

Writing your own Python modules is very simple. To create a module, we first create a new  `.py`  file with the module name in the same directory as the file that will import the module. Then we import it using the  `import`  command and the Python file name (without the .py extension)

For example, let's create a module of arithmetic operations:

#### modular_example/arithmetic.py
```py
def add(x, y):
    return x + y
def multiply(x, y):
    return x * y
def subtract(x, y):
    return x - y
```
Now, make another file in the  _same directory_  as  `arithmetic.py`  called  `calculations.py`. We can import the arithmetic module into  `calculations.py`  and run the functions by doing this...

#### modular_example/calculations.py
```py
import arithmetic
print(arithmetic.add(5, 8))
print(arithmetic.subtract(10, 5))
print(arithmetic.multiply(12, 6))
```
Note: make sure that the module and the file importing the module are in the same folder/directory.

### Standard (Built-In) Modules

Python comes with a library of standard modules. Some modules are built into the interpreter; these provide access to operations that are not part of the core of the language but are nevertheless built-in, either for efficiency or to provide access to operating system primitives such as system calls. The set of such modules is a configuration option which also depends on the underlying platform. For example, the  _winreg_  module is only provided on Windows systems. One particular module deserves special mention:  _sys_, which is built into every Python interpreter.

A list of built-in modules could be found in this  [link](https://docs.python.org/3.6/library/index.html).

#### Exploring Built-In Modules

Two very important functions come in handy when exploring modules in Python - the  `dir`  and  `help`  functions. We can look for which functions are implemented in each module by using the  `dir`  function:

<img src="https://i.ibb.co/KsDSBY2/Screen-Shot-2018-03-22-at-7-32-58-PM.png" alt="Screen-Shot-2018-03-22-at-7-32-58-PM" border="0">  

## Packages

A module is a single file (or files) that is imported under one import. A  **package**  is a collection of modules in directories that give a package hierarchy.
```py
from my_package.subdirectory import my_functions
```
Packages are namespaces which contain multiple packages and modules themselves. They are simply directories, but with a twist.
```py
sample_project
     |_____ python_file.py
     |_____ my_modules
               |_____ __init__.py
               |_____ test_module.py
               |_____ another_module.py
               |_____ third_module.py
```
In the above diagram, the package name is  _my_modules_.

#### Writing Packages

If we create a directory called  _my_modules_, which marks the package name, we can then create a module inside that package called  _test_module_.

To use the module  _test_module_, we can import it in two ways:
```py
import my_modules.test_module
```
**OR**
```py
from my_modules import test_module
```
#### `__init__.py`  File

You may have noticed the  ___init__.py_  file outlined in the structure above and wondered what it is. This file was required for all packages in Python 2.7; it would often be empty, but was required to indicate that the files in the folder were part of the package.

In Python 3.3+, we only need this file if we need to customize what modules are available to anyone attempting to import the package. For example, if we didn't want another_module or third_module to be accessible for importing, we could override the  ___all___ variable, like so:

#### sample_project/my_modules/__init__.py
```py
__all__ = ["test_module"]
```

# Assignment: Modular Practice

## Objectives:

-   Gain familiarity with modules
-   Learn about the variable  ___name___
-   Practice modularizing code

----------

For this assignment, create a folder called  _modularizing_  and follow all the steps outlined below.

## Modularizing and Importing

Remember modules are really just files. Create two Python files--call one parent and one child. We'll work with parent first. Open  `parent.py`  and insert the following:

#### modularizing/parent.py
```py
local_val = "magical unicorns"
def square(x):
    return x * x
class User:
    def __init__(self, name):
        self.name = name
    def say_hello(self):
        return "hello"
```
Now we have a document with a local variable, a function and a class. If we run this document from the command line, we will see no results. We haven't asked to print anything, nor have we called our function or class method. As we know, without printing, it's difficult to know what our code did when it ran. Let's look at our code by running our functions and printing the result.

#### modularizing/parent.py
```py
# in the same file, add the following below the User class
print(square(5))
user = User("Anna")
print(user.name)
print(user.say_hello())
```
Now, we can see in our terminal window whether our code runs as expected. Now let's see what happens when we import parent into child. In  `child.py`:

#### modularizing/child.py
```py
import parent
```
Before writing anything else, run  `child.py`. Check what's in your directory. What changed? You should see a directory called __pychache__ which contains a  `.pyc`  file. This file contains Python bytecode - the language the Python interpreter speaks. Since these files are in a language Python knows so we can run them like any other Python file: (e.g., python __pycache__/parent.cpython-36.pyc).

One way these  `.pyc`  files will be created is when a module is imported. This is why you may not have seen .pyc files before now. Once a  `.pyc`  file is generated, as long as we don't change that file, Python will not have to re-compile your code to bytecode, which may save processing time when working with large code bases.

You probably also noticed that all of your code from  `parent.py`  executed on the import statement. This means that every print statement and variable instantiation is still happening. That's fine, but let's use a concept called namespace and a built-in variable called  `__name__`  to clean up our code.

## Namespace:

Namespace refers to which variables, functions, and classes are accessible to us at any given time during a program’s execution. Namespace is important because we have to know what variables we have access to. To see what variables are available in any given place, add the line `print(locals())`  and see what variables are in your current namespace. The object that prints will be a dictionary where the variable names are keys and the objects they reference are the values. Understanding namespace will help you understand the next portion, where we will use namespace to control the functionality that is imported with our document.

Whenever we create a new file and execute it, the Python interpreter automatically creates several variables. We’ll look closer at one of them: the variable __name__. To learn how to use this variable in your own code, follow the steps below:

1.  __name__ is not only automatically created, but is also assigned a value. In your document parent.py add this line:
    
    #### modularizing/parent.py
    ```py
    print(__name__)
    ```
2.  execute  `parent.py`  from the command line
3.  You should see  ___main___ printed to the console
4.  In  `child.py`  you should already have imported parent, if not, add that line now
5.  Execute  `child.py`  from the command line
6.  You should see  _parent_ printed to the console.
7.  In  `parent.py`  add the following:
    
    #### modularizing/parent.py
    ```py
    if __name__ == "__main__":
        print("the file is being executed directly")
    else:
        print("The file is being executed because it is imported by another file. The file is called: ", __name__)
      
    ```
8.  Now try running the file directly. You should  _see the file is being executed directly_ printed in the console.
9.  Execute  `child.py`  You should see  _T__he file is being executed because it is imported by another file. The file is called: parent_
10.  How is this useful? We can use this conditional to prevent blocks of code from executing unless the file is being run directly. Why would we want to do this? Consider a situation where one class depends on another, as in the Users with Bank Accounts assignment. In our product document we might create a lot of test code to make sure we can create new products and execute methods. When we import products to the store file as a module, we don’t want to see all of those tests run every time we execute the store file, so inside of our product document, we might have something like below:
```py
if __name__ == "__main__":
    product = Product([args])
    print(product)
    print(product.add_tax(0.18))
```

# Assignment: Store & Products

## Objectives:

-   Practice creating classes
-   Practice associations between classes
-   Practice modularizing code

----------

Start by creating a Store class that has 2 attributes: a name and a list of products. The name must be provided upon creation, but the products list should be empty.

Next, create a Product class that has 3 attributes: a name, a price, and a category. All of these should be provided upon creation.

Let's give some methods to our Product class:

-   **update_price(self, percent_change, is_increased)**  - updates the product's price. If is_increased is True, the price should increase by the percent_change provided. If False, the price should decrease by the percent_change provided.
-   **print_info(self)**  - print the name of the product, its category, and its price.

Let's also give some methods to our Store class:

-   **add_product(self, new_product)**  - takes a product and adds it to the store
-   **sell_product(self, id)**  - remove the product from the store's list of products given the id (assume id is the index of the product in the list) and print its info.
-   **inflation(self, percent_increase)**  - increases the price of each product by the percent_increase given (use the method you wrote in the Product class!)
-   **set_clearance(self, category, percent_discount)**  - updates all the products matching the given category by reducing the price by the percent_discount given (use the method you wrote in the Product class!)

- [ ]  Create a Store class with 2 attributes
    
- [ ]  Create a Product class with 3 attributes
    
- [ ]  Add the print_info method to the Product class
    
- [ ]  Add the update_price method to the Product class
    
- [ ]  Add the add_product method to the Store class
    
- [ ]  Add the sell_product method to the Store class
    
- [ ]  Test out your classes by creating an instance of the Store and a few instances of the Product class, add those instances to the store instance, and then test out the methods.
    
- [ ]  NINJA BONUS: Add the inflation method to the Store class
    
- [ ]  NINJA BONUS: Add the set_clearance method to the Store class
    
- [ ]  NINJA BONUS: Modularize your code into 3 separate files
    
- [ ]  SENSEI BONUS: Update the product class to give each product a unique id. Update the sell_product method to accept the unique id.

#

# Introduction to TDD

## Objectives:

-   Introduce test-driven development (TDD)
-   Understand how the cycle of TDD differs from the traditional development cycle
-   Understand the pros and cons of TDD

----------

Imagine that you're on the dev team for an up and coming e-commerce start-up. Your product is similar to Amazon in nature where users can buy different products. Your task was to create a feature that will send each customer an invoice of their order as soon as they place their order. As you were implementing this new part of your app, you inadvertently overwrote some pre-existing code that handled payments which disabled incoming payments from being processed. However, you were unaware of this so you complete your feature and then begin testing your product, only to find out payments are not happening. The results? A missed opportunity for your company, a mess of unhappy users, and a developer who is in trouble.

## Traditional Development Cycle

The approach of above illustrates the traditional development cycle where an individual or team goes through the following cycle:

1.  Design your product or feature
2.  Build it
3.  Test it (make sure it works and pray that nothing else broke in the process)
4.  Continue to develop
5.  Repeat

<img src="https://i.ibb.co/BzbsHpZ/chapter3470-5187-traditional-diagram.png" alt="chapter3470-5187-traditional-diagram" border="0">

This may also reflect your own method in your journey as a developer! While this is not  _bad_, the hope is that we understand how this could go terribly wrong in our field as software is always changing.

## Test-Driven Development

Test-Driven Development (TDD) is a method of developing software that provides a structure to write good code and ensure an end product that has been tested in each phase of development. The model of TDD is as follows:

1.  Design a feature
2.  Write a test that fails (RED). This test will model a specific behavior or outcome in your code
3.  Write the code that will make your feature work and pass the test (GREEN).
		Also make sure that prior tests still pass!

4.	Refactor your code and improve your design
5.  Move to the next feature and repeat the process

<img src="https://i.ibb.co/swdX5PC/chapter3470-5186-tdd-diagram.png" alt="chapter3470-5186-tdd-diagram" border="0">

As you may have noticed, TDD focuses on testing throughout the entire development process rather than the beginning. Without integrated tests, the software will die as it becomes more complex and ugly because developers don't touch code for fear of breaking it.

### The Benefits

TDD will allow us to develop in such a way that:

1.  We have a clear picture of how features should work before building it out
2.  We can develop without the fear of breaking our apps
3.  We can encourage improvement and refactoring of the codebase which will lead to cleaner code

### Drawbacks

1.  Larger time investment
2.  Additional complexity of code
3.  More code to maintain

### When to use TDD and when not to

The goal of this section is to help you understand the basic principles of TDD with Python. As you move forward during the bootcamp, keep this technique in mind. However, be aware that  _during an intensive learning phase_  (such as a bootcamp), TDD can be more of a hindrance than a help, because it slows down the experimentation process and adds complexity to your applications.

Test-Driven Development is a very valuable technique to use when you intend to go a bit more slowly in order to create something that is as bug-free as possible. TDD is most valuable when you are building a production system and you know that any defect will be very expensive to your company -- such as when building Amazon.com, for example. TDD is also a great choice when writing code that you expect will be important and will be used for a very long time -- such as when building the public-facing API for your company, for example. However, it is not as useful when exploring new technology areas, since there is no real cost of an undiscovered defect, and since this code will be discarded once the technology is well-understood.

With this in mind, TDD is generally not worth the cost when working through Dojo assignments -- except perhaps for the largest ones such as your final projects for a stack. Once you understand a technology area, feel free to apply TDD, but in general we recommend that you focus on learning how to actually build applications for now.

# Unittest and Assertions

## Objectives:

-   Learn how to import the Python testing framework
-   Learn how to write a test
-   Learn how to run a test

##
<iframe width="560" height="315" src="https://www.youtube.com/embed/gMuELafPq-A" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
##

Python's unit testing framework, which was previously known as  _PyUnit_, is included in the Python standard library. Let's get started with a simple "unit" and its tests. Create a new file:

#### test_even.py
```py
# import the python testing framework
import unittest
# our "unit"
# this is what we are running our test on
def isEven(n):
    if n % 2 == 0:
       return True
    else:
       return False
# our "unit tests"
# initialized by creating a class that inherits from unittest.TestCase
class IsEvenTests(unittest.TestCase):
    # each method in this class is a test to be run
    def testTwo(self):
        self.assertEqual(isEven(2), True)
        # another way to write above is
        self.assertTrue(isEven(2))
    def testThree(self):
        self.assertEqual(isEven(3), False)
        # another way to write above is
        self.assertFalse(isEven(3))
    # any task you want run before any method above is executed, put them in the setUp method
    def setUp(self):
        # add the setUp tasks
        print("running setUp")
    # any task you want run after the tests are executed, put them in the tearDown method
    def tearDown(self):
        # add the tearDown tasks
        print("running tearDown tasks")
if __name__ == '__main__':
    unittest.main() # this runs our tests
```
In the example, above we used  `assertTrue()`  and  `assertFalse()`, which introduce the first couple of many functions/assertions available in the unittest framework. We will touch on a handful of these as we progress, but here is a good reference:  [unittest functions](https://docs.python.org/3.6/library/unittest.html#unittest.TestCase).

## Running unittest

Before anything else, let's examine how we run our tests:
```py
if __name__ == '__main__':
    unittest.main()
```
By including these two lines, we can run our test code by executing our python file. Running it with no options results in a simple output but running this file with the  `-v`  flag will give you the verbose output with information on each test that was run:

<img src="https://i.ibb.co/2sZ99qS/Screen-Shot-2018-03-23-at-10-33-14-AM.png" alt="Screen-Shot-2018-03-23-at-10-33-14-AM" border="0">

## Test Outcomes

When we run our tests, there are 3 possible outcomes:

1.  OK - all tests have passed
2.  FAIL - one or more of the tests have failed, and raises an AssertionError exception
3.  ERROR - the test raises an exception other than AssertionError

In the typical TDD workflow:

Think of Feature->Write Tests->Run & Fail->Code->Run & Pass->Refactor->Repeat

### Other Useful Assertions

If you understood the code above, implementing the other assertions are quite straight forward. Here is a list of some of the other useful assertions directly from the Python doc:

<img src="https://i.ibb.co/09WCRgL/Screen-Shot-2018-03-23-at-10-37-08-AM.png" alt="Screen-Shot-2018-03-23-at-10-37-08-AM" border="0">

Although this list is not exhaustive, keep an eye out for some of these as we continue along. If you're curious about the above or want to see all available assertions, you can check out the  [python doc - Test Cases & Assertions](https://docs.python.org/3.6/library/unittest.html#test-cases)

# Assignment: Intro to TDD

## Objectives:

-   Practice writing and running tests on an algorithm

----------

Now that you've learned how to use unittest, let's have you do the following:

1.  **reverseList**  - Write a function that reverses the values in the list (without creating a temporary array).

-   Example: reverseList([1,3,5]) should return [5,3,1]
-   Example Test: assertEqual( reverseList([1,3,5]), [5,3,1] )
-   Add at least 3 other test cases

3.  **isPalindrome**  - Write a function that checks whether the given word is a palindrome (a word that spells the same backward).

-   Example: isPalindrome("racecar") should return True
-   Example Test: assertEqual( isPalindrome("racecar"), True ) or assertTrue( isPalindrome("racecar"))
-   Example Test: assertFalse( isPalindrome("rabcr") ).
-   Add at least 5 other test cases

5.  **coins**  - Write a function that determines how many quarters, dimes, nickels, and pennies to give to a customer for a change where you minimize the number of coins you give out.

-   Example: given 87 cents, result should be 3 quarters, 1 dime, 0 nickel and 2 pennies
-   Example Test: assertEqual( coin(87), [3,1,0,2] )
-   Add at least 5 other test cases

7.  **BONUS - factorial**  - Write a  _recursive_  function that returns the factorial of a given number. Remember that the factorial of a number is the product of all the numbers between 1 and the given number (eg. 4! = 4*3*2*1).

-   Example: factorial(5) should return 120.
-   Add at least 3 test cases

9.  **BONUS - fibonacci**  - Write a  _recursive_  function that accepts a number, n, and returns the nth Fibonacci number from the sequence. The first two Fibonacci numbers are 0 and 1. Every number after that is calculated by adding the previous 2 numbers from the sequence. (i.e. 0, 1, 1, 2, 3, 5, 8, 13, 21 ...)

-   The sequence starts with fib(0) so fib(5) is actually 5 and fib(4) is 3.  [https://en.wikipedia.org/wiki/Fibonacci_number](https://en.wikipedia.org/wiki/Fibonacci_number)
-   Add at least 3 test cases

For the purpose of this assignment, do all of these in a single Python file.

- [ ]  Write a reverseList function and test it with at least 3 cases
    
- [ ]  Write an isPalindrome function and test it with at least 5 cases
    
- [ ]  Write a coins function and test it with at least 5 cases
    
- [ ]  BONUS: Write a recursive factorial function and test it with at least 3 cases
    
- [ ]  BONUS: Write a recursive fibonacci function and test it with at least 3 cases

#

# Multiple Arguments

## Objectives:

-   Create functions that can accept a varying number of arguments
-   Recognize the  _splat_  operator

----------

What if we want to pass in a varying number of arguments, or want to capture multiple arguments into a single parameter? Placing an asterisk before the name of the parameter after the "normal" parameters does just that. The asterisk is called a  **splat**  operator.
```py
def varargs(arg1, *args):
    print("Got ", arg1, " and ", args)
varargs("one") 			# output: Got one and ()
varargs("one", "two") 	        # output: Got one and ('two',)
varargs("one", "two", "three")  # output: Got one and ('two', 'three')
```
In this example, the first argument  `arg1`  is assigned to the first method parameter as usual. Notice, however, that any and all remaining arguments passed in are in the  `args`  parameter, which appears to be a tuple (as indicated by the  `()`  syntax)! Because we prefixed the final parameter with an asterisk (the splat operator), all the arguments that don't match a required parameter are  _packed_  into a single  **tuple**.

Remember that a tuple is an iterable, just like a list. That means if we want to access each of the arguments passed over individually, we can use a loop:
```py
def varargs(arg1, *args):
    for a in args:
    	print(a)
varargs("one", "two", "three") # output: two, three (on separate lines)
```

# Assignment: MathDojo

## Objectives:

-   Practice creating a class and creating new instances
-   Practice chaining methods
-   Practice writing flexible functions that can take a varying number of arguments

----------

Create a Python class called MathDojo that has one attribute,  _result_, and 2 methods:  _add_  and  _subtract_. The 2 methods each must take at least 1 parameter, but could take many more.
```py
class MathDojo:
    def __init__(self):
    	self.result = 0
    def add(self, num, *nums):
    	# your code here
    def subtract(self, num, *nums):
    	# your code here
# create an instance:
md = MathDojo()
# to test:
x = md.add(2).add(2,5,1).subtract(3,2).result
print(x)	# should print 5
# run each of the methods a few more times and check the result!
```
- [ ]  Create a MathDojo class
    
- [ ]  Write the add method and test it by calling it 3 times, with different numbers of arguments each time
    
- [ ]  Write the subtract method and test it by calling it 3 times, with different numbers of arguments each time
    
- [ ]  Make sure you are able to chain methods as demonstrated above

#

# MathDojo + TDD

## Objectives:

-   Practice using setUp()
-   Gain familiarity with how to set up tests for our code

----------

Understanding how to use TDD is extremely helpful, especially if you're interested in joining a large company where TDD is used very heavily. Get more practice using TDD by re-doing the MathDojo assignment with TDD. Make sure you use the setUp() method this time to create an instance of the MathDojo before the tests are run.
