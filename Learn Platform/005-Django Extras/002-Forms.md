# Forms

One of the goals of Django is to let developers focus on development rather than setup.

At this point in our Django journey, we should be feeling pretty good about using the MVC architecture in our apps, as well as starting to integrate multiple apps.

Now let’s talk about forms (here’s the  [documentation](https://docs.djangoproject.com/en/2.2/topics/forms/)  for reference).

Django forms basically auto-generate your HTML for your form for you, based on a variable’s  `models.fieldType`. You can then pass an instance of this class (which is the HTML) to your  `views.py`  file and, through your context variable, pass the form to your templates!

In brief:

-   `forms.py`  is a new file that we will use to set our forms
-   `views.py`  will import the new class from  `forms.py`, and invoke it as a value in the  `context`  dictionary
-   Any  **template**  that’s passed the value from  `views.py`  can access the value via  `{{}}`

For example:

> Inside a newly created  `forms.py`  file in your app
```py
# Inside your app's forms.py file
from django import forms
class RegisterForm(forms.Form):
    first_name = forms.CharField(max_length=45)
    last_name = forms.CharField(max_length=45)
    email = forms.EmailField()
    password = forms.CharField(max_length=100, widget=forms.PasswordInput)
    confirm_password = forms.CharField(max_length=100,widget=forms.PasswordInput)
```
That  `widget`  flag on the  `password`  field adjusts the default type of input field in our HTML! There are plenty of widgets out there that you can search for.

Now, in our controller:
```py
# Inside your app's views.py
from django.shortcuts import render, redirect
from .forms import RegisterForm
def index(request):
    form = RegisterForm()
    context = { "regForm": form }
    return render(request, "this_app/index.html", context)
```
And finally, in our template:
```html
<!-- Inside templates/this_app/index.html -->
<body>
  <form class="" action="/register" method="post">
    {% csrf_token %}
    {{ regForm.as_p }}
    <!--  ".as_p" is an example of an option you can attach to the form inputs
    "as_table" and "as_ul" are a few others...-->
    <input type="submit" value="register">
  </form>
</body>
```
Pretty neat, right? Here’s a quick (if you play it at 2x speed…) video of doing this for a new project.

First you'll need to start a new project with an apps folder and an app named 'formtest'.

In your settings.py, add 'formtest' to your INSTALLED_APPS list.

In your inner project folder's urls.py:

Add`path('', include('formtest.urls')),`to our urlpatterns list and change the line:
```py
from django.urls import path
```
to
```py
from django.urls import path, include
```
Next, inside formtest, you'll create a new file, urls.py:
```py
from django.urls import path
from . import views
urlpatterns = [
    path('', views.index, name='index')
]
```
And in your views.py:
```py
# add this:
from forms import RegistrationForm
# then create an index method:
def index(request):
    form = RegistrationForm() # We will build this class out in just a minute
    context = {
        'myregistrationform': form # Form is the variable name referencing the instance of our RegistrationForm class
    }
    return render(request, 'formtest/index.html', context)
```
In templates/formtest/index.html, edit your basic html snippet:
```html
<body>
    <form class="" action="/" method="post">
	{% csrf_token %}
	{{ myregistrationform }}
	<input type="submit" name="" value="Submit the form!">
    </form>
</body>
```
Create a new forms.py file in your app:
```py
from django import forms
class RegistrationForm(forms.Form):
    first_name = forms.CharField(max_length=45)
    last_name = forms.CharField(max_length=45)
    email = forms.EmailField()
    password = forms.CharField(max_length=100, widget=forms.PasswordInput)
    confirm_password = forms.CharField(max_length=100, widget=forms.PasswordInput)
```
This is great! All the underscores we use in our variable names inside our Form class are converted to spaces when the form is displayed in HTML.

Now we go back to our terminal, make migrations and migrate and then start our server. Boom! Now we can go to 'localhost:8000' in our browser and see it live!

Now if we want, we can go back to our index.html and change how it's displayed. Test all these and use your browser's inspector to see what html is generated by changing '{{ myregistrationform }}' to the following:
```
{{ myregistrationform.as_p }}
{{ myregistrationform.as_table }}
{{ myregistrationform.as_ul }}
```

# Form Validations

We can create forms using prebuilt Django methods. Now let’s validate them!

Just a reminder that this is Level III content, meaning you have more than enough in your tool belt to pass the belt exam already. These topics are here to show you more of the great tools Django offers to help develop more quickly.

Imagine we create the following form:
```py
# Inside your app's forms.py file
from django import forms
class RegisterForm(forms.Form):
    first_name = forms.CharField(max_length=45)
    last_name = forms.CharField(max_length=45)
    email = forms.EmailField()
    password = forms.CharField(max_length=100, widget=forms.PasswordInput)
    confirm_password = forms.CharField(max_length=100,widget=forms.PasswordInput)
```
Now let’s imagine a user submitted information into this form that we rendered to the browser (see the previous section if you’re unclear on how to do this).

Our  `views.py`  file now gets hit with the HTTP request and  `POST`  data, which our  `urls.py`  directs to the  `register`  function.

Now the cool part: We can instantiate a form and test the data we received against our validations!
```py
# Inside your app's views.py file
# This is the method that is running in response to that form submission
def register(request):
  # Confirm that the HTTP verb was a POST
  if request.method == "POST":
    # Bind the POST data to an instance of our RegisterForm
    bound_form = RegisterForm(request.POST)
    # Now test that bound_form using built-in methods!
    # *************************
    print(bound_form.is_valid()) # True or False, based on the validations that were set!
    print(bound_form.errors) # Any errors in this form as a dictionary
    # *************************
	return redirect('index')
```
We can  _really_  streamline things by connecting the form to a model!
```py
# inside your app's forms.py file
from django import forms
# assumes that we have a User model!
from .models import User
class RegisterForm(forms.ModelForm):
  class Meta:
      model = User
      fields = '__all__'
```
The above code generates a  `RegisterForm`  for our  `User`  model!

Here’s the  [documentation](https://docs.djangoproject.com/en/2.2/topics/forms/modelforms/#modelform)  to review.

In the next assignment, we are going to write some of our own model validations as well. Here’s a quick example of the setup:

In our app.models.py:
```py
from django.core.exceptions import ValidationError
from django.db import models
# our validator
def validateLengthGreaterThanTwo(value):
    if len(value) < 3:
        raise ValidationError(
            '{} must be longer than: 2'.format(value)
        )
class User(models.Model):
    first_name = models.CharField(max_length=45, validators = [validateLengthGreaterThanTwo])
    last_name = models.CharField(max_length=45, validators = [validateLengthGreaterThanTwo])
```
So if we had a form for our  `User`  class… (intentional ellipses)

# Assignment: MiniRegister

#### Completion time: 2-4hrs

We’ve already done login and registration a few times, so doing it again might be unnecessarily tedious. But we definitely want to be comfortable using forms and checking out Django documentation.

So… we are just going to make a registration form. Rather than using the UserManager strategy, try making validators and validations!

We haven’t explained these, so this assignment might take a little longer than you expect, but it's time to be able to dig into the primary documentation and figure stuff out!

[https://docs.djangoproject.com/en/1.10/ref/models/instances/](https://docs.djangoproject.com/en/1.10/ref/models/instances/)

[https://docs.djangoproject.com/en/1.10/ref/validators/](https://docs.djangoproject.com/en/1.10/ref/validators/)

[https://docs.djangoproject.com/en/1.10/topics/forms/modelforms/](https://docs.djangoproject.com/en/1.10/topics/forms/modelforms/)

(We know this is a lot of stuff, but in short, once you figure out validators, calling is_valid will run those validations for us!)

### Build the registration portion of the following

<img src="https://i.ibb.co/72wMf4v/chapter3844-6667-login-reg.png" border="0">

print the validation errors!

[https://docs.djangoproject.com/en/1.10/topics/forms/](https://docs.djangoproject.com/en/1.10/topics/forms/)


# Django and Flash Messages

In our level 3 experience so far we’ve figured out how to generate forms and set up our models.

Just to recap from the last assignment - If we have a bound form:
```py
from .forms import myForm
def index(request):
  if request.method = "POST":
    showForm = myForm(request.POST)
    print(showForm.errors)
    return render(request, ".... path to file")
```
Django auto-generates our forms, can test whether the data are valid, and even, if we were to reload the page, passing our bound form can even show us those errors! Pretty awesome!

Many of you figured out how to do custom messages already. Still, let's go over that process:

[https://docs.djangoproject.com/en/1.10/ref/contrib/messages/](https://docs.djangoproject.com/en/1.10/ref/contrib/messages/)

Let’s take a list (called errors) and turn it into some messages in our views and then show the template that might render those messages!

In our views.py:
```py
from django.contrib import messages
... (other normal stuff)
def make_messages(request):
	errors = [
		"First error",
		"Second error",
		"Third error"
	]
for error in errors:
	# The messages object has a number of tags (including error), and we can use this shorthand for those tags:
	messages.error(request, error)
	# the message object will be held until the next time a page is rendered.
return redirect('show_errors')
def show_errors(request):
	return render(request, 'our_app/show_errors.html')
```
In show_errors.html
```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title></title>
  </head>
  <body>
  {% if messages %}
    <ul class="messages">
        {% for message in messages %}
        <li>{{ message }}</li>
        {% endfor %}
    </ul>
  {% endif %}
  </body>
</html>
```
You can additionally add queries on the different tags, or even set extra_tags if you want custom tags (say for login and registration)!


